local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local player = Players.LocalPlayer

-- Load WindUI Library
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  GLOBAL VARIABLES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local carryAnimationEnabled = false
local carryWeldActive = false
local blackScreenEnabled = false
local blackScreenGui = nil
local fpsBoostEnabled = false
local megangCoilEnabled = false
local noclipEnabled = false

-- Stable Animation System Variables
local stableAnimationEnabled = true -- âœ¨ DEFAULT ENABLE!
local animationFadeTime = 0.1        -- âš¡ Faster fade for better performance
local jumpAnimationFadeTime = 0.25   -- âš¡ Optimized fade for jump animation
local animationPriority = Enum.AnimationPriority.Action

-- Performance Optimization Variables
local frameRateLimit = 30            -- âš¡ 30 FPS for stable recording
local optimizedRendering = true      -- ğŸ¨ Enable optimized rendering
local reducedEffects = false         -- ğŸ’¨ Disable heavy effects for performance

-- Advanced Protection Variables
local antiReportEnabled = false
local antiDetectEnabled = false
local privateModeEnabled = false
local autoLeaveAdminEnabled = false
local adminNames = {"Admin", "Moderator", "Owner", "Developer", "Staff"}
local stealthConnection = nil

_G.LoopCounter = 0
_G.ShouldAutoRestart = false
_G.RestartWithLoop = false

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function WeldRightArmForward()
    local char = player.Character
    if not char then return false end
    
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    local rightArm = char:FindFirstChild("RightUpperArm") or char:FindFirstChild("Right Arm")
    
    if not torso or not rightArm then return false end
    
    for _, joint in pairs(torso:GetChildren()) do
        if joint:IsA("Motor6D") or joint:IsA("Weld") then
            if joint.Name == "RightShoulder" or joint.Name == "RightArmWeld" then
                joint:Destroy()
            end
        end
    end
    
    local weldRight = Instance.new("Weld")
    weldRight.Name = "RightArmWeld"
    weldRight.Part0 = torso
    weldRight.Part1 = rightArm
    weldRight.C0 = CFrame.new(0.8, 0.7, -0.4) * CFrame.Angles(0, math.rad(90), math.rad(90))
    weldRight.Parent = torso
    
    return true
end

local function UnweldRightArmForward()
    local char = player.Character
    if not char then return end
    
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    if not torso then return end
    
    for _, joint in pairs(torso:GetChildren()) do
        if joint:IsA("Weld") then
            if joint.Name == "RightArmWeld" then
                joint:Destroy()
            end
        end
    end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Landed)
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local carryWelds = {}

local function WeldArmsForCarry()
    local char = player.Character
    if not char then return false end
    
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    local rightArm = char:FindFirstChild("RightUpperArm") or char:FindFirstChild("Right Arm")
    local leftArm = char:FindFirstChild("LeftUpperArm") or char:FindFirstChild("Left Arm")
    
    if not torso or not rightArm or not leftArm then return false end
    
    -- Get current CFrame positions (relative to torso)
    local rightArmCurrentC0 = torso.CFrame:ToObjectSpace(rightArm.CFrame)
    local leftArmCurrentC0 = torso.CFrame:ToObjectSpace(leftArm.CFrame)
    
    -- Remove existing joints
    for _, joint in pairs(torso:GetChildren()) do
        if joint:IsA("Motor6D") or joint:IsA("Weld") then
            if joint.Name == "RightShoulder" or joint.Name == "LeftShoulder" or 
               joint.Name == "CarryWeldRight" or joint.Name == "CarryWeldLeft" then
                joint:Destroy()
            end
        end
    end
    
    -- Weld Right Arm at CURRENT position
    local weldRight = Instance.new("Weld")
    weldRight.Name = "CarryWeldRight"
    weldRight.Part0 = torso
    weldRight.Part1 = rightArm
    weldRight.C0 = rightArmCurrentC0  -- Use current position!
    weldRight.Parent = torso
    table.insert(carryWelds, weldRight)
    
    -- Weld Left Arm at CURRENT position
    local weldLeft = Instance.new("Weld")
    weldLeft.Name = "CarryWeldLeft"
    weldLeft.Part0 = torso
    weldLeft.Part1 = leftArm
    weldLeft.C0 = leftArmCurrentC0  -- Use current position!
    weldLeft.Parent = torso
    table.insert(carryWelds, weldLeft)
    
    return true
end

local function UnweldArmsFromCarry()
    local char = player.Character
    if not char then return end
    
    -- Remove all carry welds
    for _, weld in ipairs(carryWelds) do
        if weld and weld.Parent then
            weld:Destroy()
        end
    end
    carryWelds = {}
    
    local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    if torso then
        for _, joint in pairs(torso:GetChildren()) do
            if joint:IsA("Weld") then
                if joint.Name == "CarryWeldRight" or joint.Name == "CarryWeldLeft" then
                    joint:Destroy()
                end
            end
        end
    end
    
    -- Reset humanoid state to restore normal arm joints
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:ChangeState(Enum.HumanoidStateType.Landed)
    end
    
end

local function ToggleCarryAnimation(enabled)
    carryWeldActive = enabled
    
    if enabled then
        -- Disable megang coil if active
        if megangCoilEnabled then
            megangCoilEnabled = false
            UnweldRightArmForward()
        end
        
        local success = WeldArmsForCarry()
        if success then
            WindUI:Notify({
                Title = "ï¿½ Animasi Gendong Aktif",
                Content = "animasi gendong aktig!",
                Icon = "check-circle",
            })
        else
            WindUI:Notify({
                Title = "âŒ animasi Gendong Gagal",
                Content = "Karakter tidak siap!",
                Icon = "alert-circle",
            })
            carryWeldActive = false
        end
    else
        UnweldArmsFromCarry()
        WindUI:Notify({
            Title = "ï¿½ Animasi Gendong Nonaktif",
            Content = "Animas gendong dimatikan.",
            Icon = "nonaktif",
        })
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function CreateBlackScreen()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "BlackScreenGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 999999
    
    local blackFrame = Instance.new("Frame")
    blackFrame.Name = "BlackFrame"
    blackFrame.Size = UDim2.new(1, 0, 1, 0)
    blackFrame.Position = UDim2.new(0, 0, 0, 0)
    blackFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    blackFrame.BorderSizePixel = 0
    blackFrame.Parent = screenGui
    
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 300, 0, 50)
    label.Position = UDim2.new(0.5, -150, 0.5, -25)
    label.BackgroundTransparency = 1
    label.Text = "ğŸŒ‘ LAYAR HITAM\n(FPS Boost Aktif)"
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 18
    label.Font = Enum.Font.GothamBold
    label.TextStrokeTransparency = 0
    label.Parent = screenGui
    
    screenGui.Parent = player.PlayerGui
    return screenGui
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function EnableAntiReport()
    if antiReportEnabled then return end
    
    pcall(function()
        -- Disable chat reporting
        local StarterGui = game:GetService("StarterGui")
        StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = "[ANTI-REPORT] Protection enabled",
            Color = Color3.fromRGB(0, 255, 0),
            Font = Enum.Font.SourceSansBold,
            FontSize = Enum.FontSize.Size18
        })
        
        -- Hook report function
        for _, v in pairs(getgc(true)) do
            if type(v) == "table" and rawget(v, "Report") then
                local old = v.Report
                v.Report = function(...)
                    return nil
                end
            end
        end
    end)
    
    antiReportEnabled = true
end

local function DisableAntiReport()
    antiReportEnabled = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function EnableAntiDetect()
    if antiDetectEnabled then return end
    
    pcall(function()
        -- Hide character name
        if player.Character then
            for _, v in pairs(player.Character:GetDescendants()) do
                if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
                    v.Enabled = false
                end
            end
        end
        
        -- Spoof movement detection
        local mt = getrawmetatable(game)
        local oldNamecall = mt.__namecall
        setreadonly(mt, false)
        
        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if method == "FireServer" or method == "InvokeServer" then
                if tostring(self):find("Report") or tostring(self):find("Detect") or tostring(self):find("Anticheat") then
                    return nil
                end
            end
            
            return oldNamecall(self, ...)
        end)
        
        setreadonly(mt, true)
    end)
    
    antiDetectEnabled = true
end

local function DisableAntiDetect()
    antiDetectEnabled = false
    
    pcall(function()
        if player.Character then
            for _, v in pairs(player.Character:GetDescendants()) do
                if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
                    v.Enabled = true
                end
            end
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function EnablePrivateMode()
    if privateModeEnabled then return end
    
    pcall(function()
        -- Make character invisible to other players
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Transparency = 1
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 1
                end
            end
            
            -- Hide name tag
            local head = player.Character:FindFirstChild("Head")
            if head then
                for _, child in pairs(head:GetChildren()) do
                    if child:IsA("BillboardGui") then
                        child.Enabled = false
                    end
                end
            end
        end
    end)
    
    privateModeEnabled = true
end

local function DisablePrivateMode()
    privateModeEnabled = false
    
    pcall(function()
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.Transparency = 0
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 0
                end
            end
            
            local head = player.Character:FindFirstChild("Head")
            if head then
                for _, child in pairs(head:GetChildren()) do
                    if child:IsA("BillboardGui") then
                        child.Enabled = true
                    end
                end
            end
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function CheckForAdmin()
    for _, plr in pairs(Players:GetPlayers()) do
        for _, adminName in pairs(adminNames) do
            if string.find(plr.Name:lower(), adminName:lower()) or 
               string.find(plr.DisplayName:lower(), adminName:lower()) then
                return true, plr.Name
            end
        end
        
        -- Check for admin badge or group rank
        if plr:GetRankInGroup(0) >= 250 then
            return true, plr.Name
        end
    end
    return false, nil
end

local function EnableAutoLeaveAdmin()
    if autoLeaveAdminEnabled then return end
    
    -- Check current players
    local hasAdmin, adminName = CheckForAdmin()
    if hasAdmin then
        WindUI:Notify({
            Title = "Admin Detected!",
            Content = "Leaving server... (" .. adminName .. ")",
            Icon = "alert-triangle",
        })
        task.wait(1)
        game:Shutdown()
        return
    end
    
    -- Monitor new players
    stealthConnection = Players.PlayerAdded:Connect(function(plr)
        if not autoLeaveAdminEnabled then return end
        
        task.wait(0.5)
        for _, adminName in pairs(adminNames) do
            if string.find(plr.Name:lower(), adminName:lower()) or 
               string.find(plr.DisplayName:lower(), adminName:lower()) then
                WindUI:Notify({
                    Title = "Admin Joined!",
                    Content = "Leaving server... (" .. plr.Name .. ")",
                    Icon = "user-x",
                })
                task.wait(1)
                game:Shutdown()
                return
            end
        end
    end)
    
    autoLeaveAdminEnabled = true
end

local function DisableAutoLeaveAdmin()
    if stealthConnection then
        stealthConnection:Disconnect()
        stealthConnection = nil
    end
    autoLeaveAdminEnabled = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function EnableFPSBoost()
    if fpsBoostEnabled then return end
    
    pcall(function()
        -- Enhanced FPS Boost System
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 9e9
        Lighting.Brightness = 0
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
        
        -- Set frame rate limit for stability
        if setfpscap then
            setfpscap(frameRateLimit)
        end
        
        for _, effect in pairs(Lighting:GetChildren()) do
            if effect:IsA("PostEffect") then
                effect.Enabled = false
            end
        end
        
        workspace.Terrain.WaterWaveSize = 0
        workspace.Terrain.WaterWaveSpeed = 0
        workspace.Terrain.WaterReflectance = 0
        workspace.Terrain.WaterTransparency = 0
        
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and not obj:IsDescendantOf(player.Character) then
                if obj:IsA("MeshPart") then
                    obj.RenderFidelity = Enum.RenderFidelity.Performance
                end
                obj.CastShadow = false
            end
            
            if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Smoke") or obj:IsA("Fire") or obj:IsA("Sparkles") then
                obj.Enabled = false
            elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                obj.Enabled = false
            elseif obj:IsA("Explosion") then
                obj.Visible = false
            end
        end
    end)
    
    fpsBoostEnabled = true
end

local function DisableFPSBoost()
    if not fpsBoostEnabled then return end
    
    pcall(function()
        Lighting.GlobalShadows = true
        Lighting.FogEnd = 100000
        Lighting.Brightness = 2
        settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
        
        for _, effect in pairs(Lighting:GetChildren()) do
            if effect:IsA("PostEffect") then
                effect.Enabled = true
            end
        end
    end)
    
    fpsBoostEnabled = false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  PLAYBACK PLAYER MODULE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local PlaybackPlayer = {}
PlaybackPlayer.__index = PlaybackPlayer

function PlaybackPlayer.new(character)
    if not character then return nil end
    
    local self = setmetatable({}, PlaybackPlayer)
    self.character = character
    self.humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
    self.humanoid = character:FindFirstChildOfClass("Humanoid")
    self.animator = self.humanoid and self.humanoid:FindFirstChildOfClass("Animator")
    
    self.recording = {}
    self.animationCache = {}
    self.isPlaying = false
    self.isPaused = false
    self.playbackThread = nil
    self.pausedIndex = nil
    self._lastIndex = nil
    self.loopPlayback = false
    self.playAnimations = true
    self.autoKillOnFinish = false
    self.reverseRotation = false
    self.playbackSpeed = 1.0
    self.heightOffset = 0
    self.initialPlayerY = nil
    self.initialRecordingY = nil
    
    return self
end

function PlaybackPlayer:GetRigType()
    if not self.humanoid then return "Unknown" end
    return self.humanoid.RigType.Name
end

function PlaybackPlayer:ResetHeightMarkers()
    self.initialPlayerY = nil
    self.initialRecordingY = nil
end

function PlaybackPlayer:CalculateHeightOffset()
    if self.initialPlayerY and self.initialRecordingY then
        self.heightOffset = self.initialPlayerY - self.initialRecordingY
    end
end

function PlaybackPlayer:EnsureAnimatorReady()
    if not self.animator and self.humanoid then
        self.animator = self.humanoid:FindFirstChildOfClass("Animator")
        if not self.animator then
            local animator = self.humanoid:WaitForChild("Animator", 5)
            if animator then
                self.animator = animator
                self.animationCache = {}
            end
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function PlaybackPlayer:PlayAnimationSmooth(animData, fadeTime, weight, speed)
    fadeTime = fadeTime or 0.1
    weight = weight or 1
    speed = speed or 1
    
    local animName = type(animData) == "table" and animData[1] or animData
    local track = self:LoadAnimation(animData)
    
    if track then
        if not track.IsPlaying then
            pcall(function()
                track:Play(fadeTime, weight, speed)
            end)
        end
        return track
    end
    
    return nil
end

function PlaybackPlayer:StopAnimationSmooth(track, fadeTime)
    if not track then return end
    fadeTime = fadeTime or 0.2
    
    pcall(function()
        if track.IsPlaying then
            track:Stop(fadeTime)
        end
    end)
end

function PlaybackPlayer:TransitionAnimation(oldTrack, newAnimData, fadeTime)
    fadeTime = fadeTime or 0.15
    
    if oldTrack and oldTrack.IsPlaying then
        self:StopAnimationSmooth(oldTrack, fadeTime)
    end
    
    task.wait(fadeTime * 0.5)
    
    return self:PlayAnimationSmooth(newAnimData, fadeTime)
end

function PlaybackPlayer:LoadAnimation(animData)
    local animName = type(animData) == "table" and animData[1] or animData
    local animId = type(animData) == "table" and animData[2] or nil
    
    local cacheKey = animId or animName
    if self.animationCache[cacheKey] then
        return self.animationCache[cacheKey]
    end
    
    if not self.animator then return nil end
    
    local userAnimId = nil
    
    if self.humanoid then
        local animateScript = self.humanoid.Parent:FindFirstChild("Animate")
        if animateScript then
            local animMapping = {
                WalkAnim = "walk",
                RunAnim = "run",
                JumpAnim = "jump",
                FallAnim = "fall",
                ClimbAnim = "climb",
                IdleAnim = "idle",
                SwimAnim = "swim",
                ToolNoneAnim = "toolnone"
            }
            
            local folderName = animMapping[animName] or animName:lower():gsub("anim", "")
            local animFolder = animateScript:FindFirstChild(folderName)
            
            if animFolder then
                for _, child in ipairs(animFolder:GetChildren()) do
                    if child:IsA("Animation") and child.AnimationId and child.AnimationId ~= "" then
                        userAnimId = child.AnimationId
                        break
                    end
                end
            end
        end
    end
    
    local defaultAnimations = {
        WalkAnim = "rbxassetid://507777826",
        RunAnim = "rbxassetid://507767714",  -- âœ¨ Updated to proper running animation
        JumpAnim = "rbxassetid://507765000",
        FallAnim = "rbxassetid://507767968",
        ClimbAnim = "rbxassetid://507765644",
        IdleAnim = "rbxassetid://507766388",
        SwimAnim = "rbxassetid://507784897",
        ToolNoneAnim = "rbxassetid://507777826", -- Default tool none animation (uses walk as base)
    }
    
    local finalAnimId = animId or userAnimId or defaultAnimations[animName]
    if not finalAnimId then return nil end
    
    local anim = Instance.new("Animation")
    anim.AnimationId = finalAnimId
    anim.Name = animName
    
    local success, track = pcall(function()
        return self.animator:LoadAnimation(anim)
    end)
    
    if success and track then
        self.animationCache[cacheKey] = track
        return track
    end
    
    return nil
end

function PlaybackPlayer:GetRecordingInfo()
    local frameCount = #self.recording
    local duration = frameCount > 0 and self.recording[frameCount][1] or 0
    local animFrameCount = 0
    local uniqueAnims = {}
    
    for _, frame in ipairs(self.recording) do
        if frame[6] then
            animFrameCount = animFrameCount + 1
            for _, anim in ipairs(frame[6]) do
                local animName = type(anim) == "table" and anim[1] or anim
                uniqueAnims[animName] = true
            end
        end
    end
    
    local animCount = 0
    for _ in pairs(uniqueAnims) do
        animCount = animCount + 1
    end
    
    return {
        frames = frameCount,
        duration = duration,
        animFrames = animFrameCount,
        uniqueAnims = animCount,
        heightOffset = self.heightOffset,
        rigType = self:GetRigType()
    }
end

function PlaybackPlayer:PrepareDynamicHeight(startIndex)
    startIndex = startIndex or 1
    
    if startIndex >= 1 then
        self:ResetHeightMarkers()
        
        self.initialPlayerY = self.humanoidRootPart.Position.Y
        
        if #self.recording > 0 and startIndex <= #self.recording then
            self.initialRecordingY = self.recording[startIndex][3]
        end
        
        self:CalculateHeightOffset()
    end
end

function PlaybackPlayer:LoadRecording(recordingData)
    if type(recordingData) ~= "table" then return false end
    
    if self.isPlaying then
        self:StopPlayback()
    end
    
    local converted = {}
    for _, frame in ipairs(recordingData) do
        if frame.time then
            local newFrame = {frame.time, frame.x, frame.y, frame.z, frame.ry}
            if frame.anims then newFrame[6] = frame.anims end
            table.insert(converted, newFrame)
        else
            table.insert(converted, frame)
        end
    end
    
    self.recording = converted
    self:ResetHeightMarkers()
    
    return true
end

function PlaybackPlayer:FindNearestWaypoint()
    if #self.recording == 0 then return 1 end
    
    local currentPos = self.humanoidRootPart.Position
    local nearestIndex = 1
    local nearestDistance = math.huge
    
    for i, frame in ipairs(self.recording) do
        local framePos = Vector3.new(frame[2], frame[3], frame[4])
        local distance = (currentPos - framePos).Magnitude
        
        if distance < nearestDistance then
            nearestDistance = distance
            nearestIndex = i
        end
    end
    
    return nearestIndex, nearestDistance
end

function PlaybackPlayer:WalkToNearestPosition(callback)
    if not self.humanoid or not self.humanoidRootPart then return false end
    if #self.recording == 0 then return false end
    
    local nearestIndex, nearestDistance = self:FindNearestWaypoint()
    
    if nearestDistance <= 5 then
        if callback then callback(nearestIndex) end
        return true
    end
    
    local targetPos = Vector3.new(
        self.recording[nearestIndex][2],
        self.recording[nearestIndex][3],
        self.recording[nearestIndex][4]
    )
    
    self.humanoid:MoveTo(targetPos)
    
    local startTime = tick()
    local maxWaitTime = 30
    
    task.spawn(function()
        while tick() - startTime < maxWaitTime do
            if not self.humanoidRootPart or not self.humanoidRootPart.Parent then
                return
            end
            
            local currentDist = (self.humanoidRootPart.Position - targetPos).Magnitude
            
            if currentDist <= 5 then
                self.humanoid:MoveTo(self.humanoidRootPart.Position)
                task.wait(0.3)
                if callback then callback(nearestIndex) end
                return
            end
            
            task.wait(0.05)
        end
        
        self.humanoid:MoveTo(self.humanoidRootPart.Position)
        task.wait(0.3)
        if callback then callback(nearestIndex) end
    end)
    
    return true
end

function PlaybackPlayer:PlayRecording(loop, startIndex, skipWalk)
    if self.isPlaying then 
        return false 
    end
    if #self.recording == 0 then 
        return false 
    end
    if not self.humanoidRootPart or not self.humanoidRootPart.Parent then 
        return false 
    end
    
    self:EnsureAnimatorReady()
    
    -- Auto walk to nearest position if too far
    if not startIndex and not skipWalk then
        local nearestIndex, nearestDistance = self:FindNearestWaypoint()
        
        if nearestDistance > 5 then
            self:WalkToNearestPosition(function(reachedIndex)
                self:PlayRecording(loop, reachedIndex, true)
            end)
            return true
        else
            startIndex = nearestIndex
        end
    end
    
    startIndex = startIndex or 1
    
    if not self.initialPlayerY or not self.initialRecordingY then
        self:PrepareDynamicHeight(startIndex)
    end
    
    self.loopPlayback = loop or false
    self.isPlaying = true
    self.isPaused = false
    
    if self.animator and self.playAnimations then
        pcall(function()
            for _, track in ipairs(self.animator:GetPlayingAnimationTracks()) do
                track:Stop(0)
            end
        end)
    end
    
    self.playbackThread = task.spawn(function()
        local shouldContinue = true
        
        while self.isPlaying and shouldContinue do
            local recordingIndex = startIndex
            local currentAnimTracks = {}
            
            local realStartTime = tick()
            local timeOffset = recordingIndex > 1 and self.recording[recordingIndex][1] or 0
            local accumulatedTime = timeOffset
            
            while self.isPlaying and recordingIndex <= #self.recording do
                self._lastIndex = recordingIndex
                
                if self.isPaused then
                    self.pausedIndex = recordingIndex
                    break
                end
                
                if not self.humanoidRootPart or not self.humanoidRootPart.Parent then
                    break
                end
                
                local currentRealTime = tick()
                local realDelta = currentRealTime - realStartTime
                realStartTime = currentRealTime
                
                local scaledDelta = realDelta * self.playbackSpeed
                accumulatedTime = accumulatedTime + scaledDelta
                
                while recordingIndex < #self.recording and self.recording[recordingIndex + 1][1] <= accumulatedTime do
                    recordingIndex = recordingIndex + 1
                end
                
                if recordingIndex < #self.recording then
                    local current = self.recording[recordingIndex]
                    local next = self.recording[recordingIndex + 1]
                    local timeDiff = next[1] - current[1]
                    
                    if timeDiff > 0 then
                        local alpha = math.clamp((accumulatedTime - current[1]) / timeDiff, 0, 1)
                        
                        local pos1 = Vector3.new(current[2], current[3] + self.heightOffset, current[4])
                        local pos2 = Vector3.new(next[2], next[3] + self.heightOffset, next[4])
                        local newPos = pos1:Lerp(pos2, alpha)
                        
                        local ry1 = current[5]
                        local ry2 = next[5]
                        
                        local diff = ry2 - ry1
                        if diff > math.pi then
                            ry2 = ry2 - 2 * math.pi
                        elseif diff < -math.pi then
                            ry2 = ry2 + 2 * math.pi
                        end
                        
                        local newRY = ry1 + (ry2 - ry1) * alpha
                        
                        local isClimbing = false
                        if current[6] and self.playAnimations then
                            for _, animData in ipairs(current[6]) do
                                local animName = type(animData) == "table" and animData[1] or animData
                                if animName == "ClimbAnim" then
                                    isClimbing = true
                                    break
                                end
                            end
                        end
                        
                        if self.reverseRotation and not isClimbing then
                            newRY = newRY + math.pi
                        end
                        
                        local newCFrame = CFrame.new(newPos) * CFrame.Angles(0, newRY, 0)
                        pcall(function()
                            self.humanoidRootPart.CFrame = newCFrame
                        end)
                        
                        -- Handle animations with STABLE PLAYBACK SYSTEM
                        if current[6] and self.animator and self.playAnimations then
                            pcall(function()
                                local currentAnims = {}
                                local hasToolNoneAnim = false
                                
                                -- Check if ToolNoneAnim already exists
                                for _, animData in ipairs(current[6]) do
                                    local animName = type(animData) == "table" and animData[1] or animData
                                    if animName == "ToolNoneAnim" then
                                        hasToolNoneAnim = true
                                        break
                                    end
                                end
                                
                                -- Auto-inject ToolNoneAnim if megangCoilEnabled and not already present
                                local animsToPlay = {}
                                for _, animData in ipairs(current[6]) do
                                    table.insert(animsToPlay, animData)
                                end
                                
                                if megangCoilEnabled and not hasToolNoneAnim then
                                    table.insert(animsToPlay, "ToolNoneAnim")
                                end
                                
                                -- Play all animations with SMOOTH TRANSITIONS (if stable mode enabled)
                                local fadeTime = stableAnimationEnabled and animationFadeTime or 0.1
                                
                                for _, animData in ipairs(animsToPlay) do
                                    local animName = type(animData) == "table" and animData[1] or animData
                                    local animId = type(animData) == "table" and animData[2] or nil
                                    
                                    local cacheKey = animId or animName
                                    currentAnims[cacheKey] = true
                                    
                                    if not currentAnimTracks[cacheKey] then
                                        local track = self:LoadAnimation(animData)
                                        if track then
                                            -- STABLE: Use smooth fade-in with priority
                                            if stableAnimationEnabled then
                                                track.Priority = animationPriority
                                                -- âš¡ Use longer fade time for jump animation
                                                local actualFadeTime = (animName == "JumpAnim") and jumpAnimationFadeTime or fadeTime
                                                -- ğŸš€ Apply playback speed to animation for realistic movement
                                                local animSpeed = self.playbackSpeed or 1
                                                if animName == "RunAnim" then
                                                    animSpeed = math.max(animSpeed * 1.2, 1.2) -- Make running more dynamic
                                                end
                                                track:Play(actualFadeTime, 1, animSpeed)
                                            else
                                                local animSpeed = self.playbackSpeed or 1
                                                if animName == "RunAnim" then
                                                    animSpeed = math.max(animSpeed * 1.2, 1.2)
                                                end
                                                track:Play(0.1, 1, animSpeed)
                                            end
                                            currentAnimTracks[cacheKey] = track
                                        end
                                    end
                                end
                                
                                -- Stop animations that are no longer needed with SMOOTH FADE-OUT
                                for key, track in pairs(currentAnimTracks) do
                                    if not currentAnims[key] then
                                        -- âš¡ Use longer fade time when stopping jump animation
                                        local isJumpAnim = key:find("jump") ~= nil or key:find("Jump") ~= nil
                                        local stopFade = isJumpAnim and jumpAnimationFadeTime or (stableAnimationEnabled and animationFadeTime or 0.1)
                                        track:Stop(stopFade)
                                        currentAnimTracks[key] = nil
                                    end
                                end
                            end)
                        elseif megangCoilEnabled and self.animator and self.playAnimations then
                            -- If no animation data exists but megangCoil is enabled, play ToolNoneAnim
                            pcall(function()
                                if not currentAnimTracks["ToolNoneAnim"] then
                                    local track = self:LoadAnimation("ToolNoneAnim")
                                    if track then
                                        local animSpeed = self.playbackSpeed or 1
                                        track:Play(0.1, 1, animSpeed)
                                        currentAnimTracks["ToolNoneAnim"] = track
                                    end
                                end
                            end)
                        end
                    end
                else
                    local frame = self.recording[recordingIndex]
                    local pos = Vector3.new(frame[2], frame[3] + self.heightOffset, frame[4])
                    local rotation = frame[5]
                    
                    local isClimbing = false
                    local hasToolNoneAnim = false
                    if frame[6] and self.playAnimations then
                        for _, animData in ipairs(frame[6]) do
                            local animName = type(animData) == "table" and animData[1] or animData
                            if animName == "ClimbAnim" then
                                isClimbing = true
                            end
                            if animName == "ToolNoneAnim" then
                                hasToolNoneAnim = true
                            end
                            
                            -- Handle jump animation specifically
                            if animName == "JumpAnim" and not currentAnimTracks["JumpAnim"] then
                                pcall(function()
                                    local track = self:LoadAnimation(animData)
                                    if track then
                                        track.Priority = animationPriority
                                        local animSpeed = self.playbackSpeed or 1
                                        track:Play(jumpAnimationFadeTime, 1, animSpeed)
                                        currentAnimTracks["JumpAnim"] = track
                                    end
                                end)
                            end
                        end
                        
                        -- Auto-inject ToolNoneAnim if megangCoilEnabled
                        if megangCoilEnabled and not hasToolNoneAnim and self.animator then
                            pcall(function()
                                if not currentAnimTracks["ToolNoneAnim"] then
                                    local track = self:LoadAnimation("ToolNoneAnim")
                                    if track then
                                        local animSpeed = self.playbackSpeed or 1
                                        track:Play(0.1, 1, animSpeed)
                                        currentAnimTracks["ToolNoneAnim"] = track
                                    end
                                end
                            end)
                        end
                    elseif megangCoilEnabled and self.animator and self.playAnimations then
                        -- If no animation data but megangCoil enabled, play ToolNoneAnim
                        pcall(function()
                            if not currentAnimTracks["ToolNoneAnim"] then
                                local track = self:LoadAnimation("ToolNoneAnim")
                                if track then
                                    local animSpeed = self.playbackSpeed or 1
                                    track:Play(0.1, 1, animSpeed)
                                    currentAnimTracks["ToolNoneAnim"] = track
                                end
                            end
                        end)
                    end
                    
                    if self.reverseRotation and not isClimbing then
                        rotation = rotation + math.pi
                    end
                    
                    local cf = CFrame.new(pos) * CFrame.Angles(0, rotation, 0)
                    pcall(function()
                        self.humanoidRootPart.CFrame = cf
                    end)
                    
                    if accumulatedTime >= frame[1] + 0.1 then
                        recordingIndex = recordingIndex + 1
                        break
                    end
                end
                
                task.wait()
            end
            
            pcall(function()
                for _, track in pairs(currentAnimTracks) do
                    if track then 
                        track:Stop(0.2) 
                    end
                end
            end)
            
            if self.isPaused then
                break
            end
            
            if recordingIndex > #self.recording then
                _G.LoopCounter = (_G.LoopCounter or 0) + 1
                
                -- ğŸ”„ Enhanced loop logic with better error handling
                if self.autoKillOnFinish and self.loopPlayback then
                    _G.ShouldAutoRestart = true
                    _G.RestartWithLoop = true
                    local hum = self.humanoid
                    if hum and hum.Health > 0 then
                        hum.Health = 0
                    end
                    return
                end
                
                if not self.loopPlayback then
                    shouldContinue = false
                    break
                end
                
                -- ğŸ›¡ï¸ Additional safety checks before loop restart
                if not self.humanoidRootPart or not self.humanoidRootPart.Parent then
                    _G.ShouldAutoRestart = true
                    _G.RestartWithLoop = self.loopPlayback
                    self.isPlaying = false
                    return
                end
                
                if not self.humanoid or self.humanoid.Health <= 0 then
                    _G.ShouldAutoRestart = true
                    _G.RestartWithLoop = self.loopPlayback
                    self.isPlaying = false
                    return
                end
                
                -- ğŸ”„ Smooth loop restart with proper delay
                task.wait(0.3) -- Reduced delay for smoother looping
                
                -- âš¡ Reset everything for clean loop restart
                self:ResetHeightMarkers()
                if self.humanoidRootPart then
                    self.initialPlayerY = self.humanoidRootPart.Position.Y
                end
                if #self.recording > 0 then
                    self.initialRecordingY = self.recording[1][3]
                end
                self:CalculateHeightOffset()
                
                -- ğŸ¯ Ensure loop continues properly
                startIndex = 1
                recordingIndex = 1 -- Reset index for next loop
                accumulatedTime = 0 -- Reset time accumulator
                realStartTime = tick() -- Reset timing
                
                -- ğŸ”„ Continue the loop without breaking
                -- shouldContinue remains true to continue looping
            end
        end
        
        if not self.isPaused then
            self.isPlaying = false
        end
    end)
    
    return true
end

function PlaybackPlayer:PausePlayback()
    if not self.isPlaying or self.isPaused then 
        return false 
    end
    
    self.isPaused = true
    self.pausedIndex = self._lastIndex or 1
    
    task.wait(0.1)
    self.isPlaying = false
    
    return true
end

function PlaybackPlayer:ResumePaused()
    if not self.isPaused then 
        return false 
    end
    
    self.isPaused = false
    self.pausedIndex = nil -- Hapus index pause lama
    
    local shouldLoop = self.loopPlayback
    
    -- ğŸ¯ LOGIKA BARU: Cari nearest waypoint dari posisi saat ini
    local nearestIndex, nearestDistance = self:FindNearestWaypoint()
    
    if nearestDistance > 5 then
        -- Jika terlalu jauh, karakter berjalan ke nearest point, lalu start
        self:WalkToNearestPosition(function(reachedIndex)
            self:PlayRecording(shouldLoop, reachedIndex, true)
        end)
        return true
    else
        -- Jika sudah dekat, langsung start dari nearest index
        return self:PlayRecording(shouldLoop, nearestIndex, true)
    end
end


function PlaybackPlayer:StopPlayback()
    if self.isPlaying and not self.isPaused then
        self.pausedIndex = self._lastIndex or 1
    end
    
    self.isPlaying = false
    self.isPaused = false
    
    if self.playbackThread then
        task.cancel(self.playbackThread)
        self.playbackThread = nil
    end
    
    if self.animator then
        pcall(function()
            for _, track in ipairs(self.animator:GetPlayingAnimationTracks()) do
                track:Stop(0.2)
            end
        end)
    end
end

function PlaybackPlayer:RebindCharacter(newChar)
    self.character = newChar
    local hrp = newChar:FindFirstChild("HumanoidRootPart") or newChar:WaitForChild("HumanoidRootPart", 5)
    local hum = newChar:FindFirstChildOfClass("Humanoid")
    
    local animator = nil
    if hum then
        animator = hum:FindFirstChildOfClass("Animator")
        if not animator then
            animator = hum:WaitForChild("Animator", 5)
        end
    end
    
    self.humanoidRootPart = hrp
    self.humanoid = hum
    self.animator = animator
    self.animationCache = {}
    
    self.isPlaying = false
    self.isPaused = false
    self.playbackThread = nil
    self.initialPlayerY = nil
    self.initialRecordingY = nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  PLAYER INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local playbackPlayer
local isLoopEnabled = false

local function initPlayer()
    local char = player.Character or player.CharacterAdded:Wait()
    if playbackPlayer then
        playbackPlayer:RebindCharacter(char)
        return true
    else
        playbackPlayer = PlaybackPlayer.new(char)
        return playbackPlayer ~= nil
    end
end

initPlayer()

player.CharacterAdded:Connect(function(newChar)
    task.spawn(function()
        newChar:WaitForChild("HumanoidRootPart", 10)
        
        if playbackPlayer then
            playbackPlayer:RebindCharacter(newChar)
        else
            initPlayer()
        end
        
        -- Re-apply features after respawn
        task.wait(0.5)
        
        if megangCoilEnabled then
            WeldRightArmForward()
        end
        
        if carryWeldActive then
            WeldArmsForCarry()
        end
        
        if blackScreenEnabled then
            CreateBlackScreen()
        end
        
        if fpsBoostEnabled then
            ApplyFPSBoost()
        end
        
        if _G.ShouldAutoRestart and playbackPlayer and #playbackPlayer.recording > 0 then
            task.wait(1.5) -- Wait for character to fully load
            
            -- ğŸ”„ Enhanced auto-restart with better error handling
            local maxRetries = 3
            local retryCount = 0
            
            while retryCount < maxRetries and _G.ShouldAutoRestart do
                retryCount = retryCount + 1
                
                -- Ensure character is ready
                if playbackPlayer.humanoidRootPart and playbackPlayer.humanoid then
                    -- Reset loop state
                    playbackPlayer:ResetHeightMarkers()
                    playbackPlayer:EnsureAnimatorReady()
                    
                    -- Attempt to restart playback
                    if playbackPlayer:PlayRecording(_G.RestartWithLoop, 1, true) then
                        -- Auto-restart successful (silent)
                        _G.ShouldAutoRestart = false
                        break
                    else
                        -- Retry failed, wait and try again
                        task.wait(1)
                    end
                else
                    -- Character not ready, wait and retry
                    task.wait(0.5)
                end
            end
            
            -- If all retries failed, disable auto restart (silent)
            if retryCount >= maxRetries then
                _G.ShouldAutoRestart = false
                _G.RestartWithLoop = false
            end
        end
    end)
end)

RunService.Stepped:Connect(function()
    if noclipEnabled and playbackPlayer and playbackPlayer.character then
        for _, p in ipairs(playbackPlayer.character:GetDescendants()) do
            if p:IsA("BasePart") then
                p.CanCollide = false
            end
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  WINDUI INTERFACE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Window = WindUI:CreateWindow({
    Title = "Pler Kuda",
    Icon = "https://cdn.discordapp.com/avatars/1427542794670444544/2b394531afe20d3a14eda2b83d53e510.png?size=4096",
    Author = "PlerKuda",
    Folder = "AutoWalkPlayer",
    
    OpenButton = {
        Title = "Plerkuda",
        Icon = "https://cdn.discordapp.com/avatars/1427542794670444544/2b394531afe20d3a14eda2b83d53e510.png?size=4096",
        CornerRadius = UDim.new(0, 8),
        StrokeThickness = 2,
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,
        
        Color = ColorSequence.new(
            Color3.fromHex("#6366f1"), 
            Color3.fromHex("#8b5cf6")
        )
    }
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  FLOATING TOGGLE FRAME (MUNCUL SAAT MINIMIZE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function CreateFloatingToggle()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "FloatingToggleGui"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Detect device type
    local UserInputService = game:GetService("UserInputService")
    local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
    
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    -- Responsive size: mobile lebih besar, PC lebih kecil
    if isMobile then
        MainFrame.Size = UDim2.new(0, 350, 0, 140)
        MainFrame.Position = UDim2.new(0.5, -175, 0.5, -70)
    else
        MainFrame.Size = UDim2.new(0, 300, 0, 120)
        MainFrame.Position = UDim2.new(0.5, -150, 0.5, -60)
    end
    MainFrame.BackgroundColor3 = Color3.fromRGB(15, 23, 42)
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = ScreenGui
    
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 12)
    UICorner.Parent = MainFrame
    
    local UIStroke = Instance.new("UIStroke")
    UIStroke.Color = Color3.fromRGB(99, 102, 241)
    UIStroke.Thickness = 2
    UIStroke.Parent = MainFrame
    
    -- Draggable
    local dragging, dragInput, dragStart, startPos
    
    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    
    -- Title
    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Size = UDim2.new(1, -50, 0, 30)
    Title.Position = UDim2.new(0, 10, 0, 5)
    Title.BackgroundTransparency = 1
    Title.Text = "Quick Controls"
    Title.TextColor3 = Color3.fromRGB(248, 250, 252)
    Title.TextSize = isMobile and 18 or 16
    Title.Font = Enum.Font.GothamBold
    Title.TextXAlignment = Enum.TextXAlignment.Left
    Title.Parent = MainFrame
    
    -- Close Button
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0, 30, 0, 30)
    CloseButton.Position = UDim2.new(1, -35, 0, 5)
    CloseButton.BackgroundColor3 = Color3.fromRGB(239, 68, 68)
    CloseButton.BorderSizePixel = 0
    CloseButton.Text = "âœ•"
    CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseButton.TextSize = isMobile and 20 or 18
    CloseButton.Font = Enum.Font.GothamBold
    CloseButton.Parent = MainFrame
    
    local CloseButtonCorner = Instance.new("UICorner")
    CloseButtonCorner.CornerRadius = UDim.new(0, 6)
    CloseButtonCorner.Parent = CloseButton
    
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
        WindUI:Notify({
            Title = "Closed",
            Content = "Floating controls ditutup",
            Icon = "x",
        })
    end)
    
    -- Toggle 1: Play from Nearest
    local Toggle1 = Instance.new("TextButton")
    Toggle1.Name = "Toggle1"
    if isMobile then
        Toggle1.Size = UDim2.new(1, -20, 0, 40)
        Toggle1.Position = UDim2.new(0, 10, 0, 45)
    else
        Toggle1.Size = UDim2.new(1, -20, 0, 30)
        Toggle1.Position = UDim2.new(0, 10, 0, 40)
    end
    Toggle1.BackgroundColor3 = Color3.fromRGB(30, 41, 59)
    Toggle1.BorderSizePixel = 0
    Toggle1.Text = ""
    Toggle1.Parent = MainFrame
    
    local Toggle1Corner = Instance.new("UICorner")
    Toggle1Corner.CornerRadius = UDim.new(0, 6)
    Toggle1Corner.Parent = Toggle1
    
    local Toggle1Label = Instance.new("TextLabel")
    Toggle1Label.Size = UDim2.new(1, -60, 1, 0)
    Toggle1Label.Position = UDim2.new(0, 10, 0, 0)
    Toggle1Label.BackgroundTransparency = 1
    Toggle1Label.Text = "ğŸ“ Play from Nearest"
    Toggle1Label.TextColor3 = Color3.fromRGB(203, 213, 225)
    Toggle1Label.TextSize = isMobile and 16 or 14
    Toggle1Label.Font = Enum.Font.Gotham
    Toggle1Label.TextXAlignment = Enum.TextXAlignment.Left
    Toggle1Label.Parent = Toggle1
    
    local Toggle1Switch = Instance.new("Frame")
    Toggle1Switch.Name = "Switch"
    if isMobile then
        Toggle1Switch.Size = UDim2.new(0, 50, 0, 26)
        Toggle1Switch.Position = UDim2.new(1, -60, 0.5, -13)
    else
        Toggle1Switch.Size = UDim2.new(0, 40, 0, 20)
        Toggle1Switch.Position = UDim2.new(1, -50, 0.5, -10)
    end
    Toggle1Switch.BackgroundColor3 = Color3.fromRGB(71, 85, 105)
    Toggle1Switch.BorderSizePixel = 0
    Toggle1Switch.Parent = Toggle1
    
    local Toggle1SwitchCorner = Instance.new("UICorner")
    Toggle1SwitchCorner.CornerRadius = UDim.new(1, 0)
    Toggle1SwitchCorner.Parent = Toggle1Switch
    
    local Toggle1Knob = Instance.new("Frame")
    Toggle1Knob.Name = "Knob"
    if isMobile then
        Toggle1Knob.Size = UDim2.new(0, 22, 0, 22)
        Toggle1Knob.Position = UDim2.new(0, 2, 0.5, -11)
    else
        Toggle1Knob.Size = UDim2.new(0, 16, 0, 16)
        Toggle1Knob.Position = UDim2.new(0, 2, 0.5, -8)
    end
    Toggle1Knob.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
    Toggle1Knob.BorderSizePixel = 0
    Toggle1Knob.Parent = Toggle1Switch
    
    local Toggle1KnobCorner = Instance.new("UICorner")
    Toggle1KnobCorner.CornerRadius = UDim.new(1, 0)
    Toggle1KnobCorner.Parent = Toggle1Knob
    
    local toggle1State = false
    Toggle1.MouseButton1Click:Connect(function()
        toggle1State = not toggle1State
        
        if toggle1State then
            Toggle1Switch.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            if isMobile then
                Toggle1Knob:TweenPosition(UDim2.new(1, -24, 0.5, -11), "Out", "Quad", 0.2, true)
            else
                Toggle1Knob:TweenPosition(UDim2.new(1, -18, 0.5, -8), "Out", "Quad", 0.2, true)
            end
            
            -- Play from nearest
            if not playbackPlayer or #playbackPlayer.recording == 0 then
                WindUI:Notify({
                    Title = "Error",
                    Content = "Load mountain terlebih dahulu!",
                    Icon = "alert-circle",
                })
                toggle1State = false
                Toggle1Switch.BackgroundColor3 = Color3.fromRGB(71, 85, 105)
                if isMobile then
                    Toggle1Knob:TweenPosition(UDim2.new(0, 2, 0.5, -11), "Out", "Quad", 0.2, true)
                else
                    Toggle1Knob:TweenPosition(UDim2.new(0, 2, 0.5, -8), "Out", "Quad", 0.2, true)
                end
                return
            end
            
            playbackPlayer.isPaused = false
            playbackPlayer.pausedIndex = nil
            _G.LoopCounter = 0
            
            playbackPlayer:ResetHeightMarkers()
            playbackPlayer:EnsureAnimatorReady()
            
            -- ğŸ”„ Enhanced loop state management
            playbackPlayer.loopPlayback = isLoopEnabled
            playbackPlayer.autoKillOnFinish = false -- Disable auto kill for smoother looping
            _G.ShouldAutoRestart = isLoopEnabled
            _G.RestartWithLoop = isLoopEnabled
            
            -- Notify user about playback start
            WindUI:Notify({
                Title = "â–¶ï¸ Auto Walk Started",
                Content = isLoopEnabled and "Dengan infinite loop" or "Single run",
                Icon = "play",
            })
            
            -- Walk to nearest position first, then start playback
            local nearestIndex, nearestDistance = playbackPlayer:FindNearestWaypoint()
            
            if nearestDistance > 5 then
                -- Walk to the nearest position
                playbackPlayer:WalkToNearestPosition(function(reachedIndex)
                    -- Start playback after reaching the position
                    playbackPlayer:PlayRecording(isLoopEnabled, reachedIndex, true)
                end)
            else
                -- Already close, start directly
                playbackPlayer:PlayRecording(isLoopEnabled, nearestIndex, true)
            end
        else
            Toggle1Switch.BackgroundColor3 = Color3.fromRGB(71, 85, 105)
            Toggle1Knob:TweenPosition(UDim2.new(0, 2, 0.5, -8), "Out", "Quad", 0.2, true)
            
            -- Stop
            if playbackPlayer then
                playbackPlayer:StopPlayback()
                playbackPlayer.loopPlayback = false
                _G.ShouldAutoRestart = false
                
                WindUI:Notify({
                    Title = "Stopped",
                    Content = "Auto walk dihentikan",
                    Icon = "check",
                })
            end
        end
    end)
    
    -- Toggle 2: Reverse Rotation
    local Toggle2 = Instance.new("TextButton")
    Toggle2.Name = "Toggle2"
    if isMobile then
        Toggle2.Size = UDim2.new(1, -20, 0, 40)
        Toggle2.Position = UDim2.new(0, 10, 0, 90)
    else
        Toggle2.Size = UDim2.new(1, -20, 0, 30)
        Toggle2.Position = UDim2.new(0, 10, 0, 75)
    end
    Toggle2.BackgroundColor3 = Color3.fromRGB(30, 41, 59)
    Toggle2.BorderSizePixel = 0
    Toggle2.Text = ""
    Toggle2.Parent = MainFrame
    
    local Toggle2Corner = Instance.new("UICorner")
    Toggle2Corner.CornerRadius = UDim.new(0, 6)
    Toggle2Corner.Parent = Toggle2
    
    local Toggle2Label = Instance.new("TextLabel")
    Toggle2Label.Size = UDim2.new(1, -60, 1, 0)
    Toggle2Label.Position = UDim2.new(0, 10, 0, 0)
    Toggle2Label.BackgroundTransparency = 1
    Toggle2Label.Text = "ğŸ”„ Reverse Rotation"
    Toggle2Label.TextColor3 = Color3.fromRGB(203, 213, 225)
    Toggle2Label.TextSize = isMobile and 16 or 14
    Toggle2Label.Font = Enum.Font.Gotham
    Toggle2Label.TextXAlignment = Enum.TextXAlignment.Left
    Toggle2Label.Parent = Toggle2
    
    local Toggle2Switch = Instance.new("Frame")
    Toggle2Switch.Name = "Switch"
    if isMobile then
        Toggle2Switch.Size = UDim2.new(0, 50, 0, 26)
        Toggle2Switch.Position = UDim2.new(1, -60, 0.5, -13)
    else
        Toggle2Switch.Size = UDim2.new(0, 40, 0, 20)
        Toggle2Switch.Position = UDim2.new(1, -50, 0.5, -10)
    end
    Toggle2Switch.BackgroundColor3 = Color3.fromRGB(71, 85, 105)
    Toggle2Switch.BorderSizePixel = 0
    Toggle2Switch.Parent = Toggle2
    
    local Toggle2SwitchCorner = Instance.new("UICorner")
    Toggle2SwitchCorner.CornerRadius = UDim.new(1, 0)
    Toggle2SwitchCorner.Parent = Toggle2Switch
    
    local Toggle2Knob = Instance.new("Frame")
    Toggle2Knob.Name = "Knob"
    if isMobile then
        Toggle2Knob.Size = UDim2.new(0, 22, 0, 22)
        Toggle2Knob.Position = UDim2.new(0, 2, 0.5, -11)
    else
        Toggle2Knob.Size = UDim2.new(0, 16, 0, 16)
        Toggle2Knob.Position = UDim2.new(0, 2, 0.5, -8)
    end
    Toggle2Knob.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
    Toggle2Knob.BorderSizePixel = 0
    Toggle2Knob.Parent = Toggle2Switch
    
    local Toggle2KnobCorner = Instance.new("UICorner")
    Toggle2KnobCorner.CornerRadius = UDim.new(1, 0)
    Toggle2KnobCorner.Parent = Toggle2Knob
    
    local toggle2State = false
    Toggle2.MouseButton1Click:Connect(function()
        toggle2State = not toggle2State
        
        if toggle2State then
            Toggle2Switch.BackgroundColor3 = Color3.fromRGB(99, 102, 241)
            if isMobile then
                Toggle2Knob:TweenPosition(UDim2.new(1, -24, 0.5, -11), "Out", "Quad", 0.2, true)
            else
                Toggle2Knob:TweenPosition(UDim2.new(1, -18, 0.5, -8), "Out", "Quad", 0.2, true)
            end
        else
            Toggle2Switch.BackgroundColor3 = Color3.fromRGB(71, 85, 105)
            if isMobile then
                Toggle2Knob:TweenPosition(UDim2.new(0, 2, 0.5, -11), "Out", "Quad", 0.2, true)
            else
                Toggle2Knob:TweenPosition(UDim2.new(0, 2, 0.5, -8), "Out", "Quad", 0.2, true)
            end
        end
        
        if playbackPlayer then
            playbackPlayer.reverseRotation = toggle2State
        end
        
        WindUI:Notify({
            Title = toggle2State and "Enabled" or "Disabled",
            Content = toggle2State and "Reverse rotation aktif" or "Reverse rotation nonaktif",
            Icon = "rotate-ccw",
        })
    end)
    
    ScreenGui.Parent = player.PlayerGui
    return ScreenGui
end

-- Create floating toggle
local FloatingToggleGui = CreateFloatingToggle()

Window:Tag({
    Title = "v3.0",
    Color = Color3.fromHex("#6366f1")
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  MOUNTAIN LOADING FUNCTION (MULTIPLE URL SUPPORT)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function LoadMountain(name, urls)
    if not playbackPlayer then
        WindUI:Notify({
            Title = "Error",
            Content = "Player belum siap!",
            Icon = "alert-circle",
        })
        return
    end
    
    -- Pastikan urls adalah tabel, konversi single URL jika perlu
    local urlList = {}
    if type(urls) == "string" then
        table.insert(urlList, urls)
    elseif type(urls) == "table" then
        urlList = urls
    else
        WindUI:Notify({
            Title = "Error",
            Content = "URL/URL List tidak valid.",
            Icon = "x",
        })
        return
    end

    if playbackPlayer.isPlaying or playbackPlayer.isPaused then
        playbackPlayer:StopPlayback()
        playbackPlayer.loopPlayback = false
        _G.ShouldAutoRestart = false
        task.wait(0.2)
    end
    
    WindUI:Notify({
        Title = "Loading",
        Content = string.format("Memuat %s (%d file)...", name, #urlList),
        Icon = "download",
    })
    
    local combinedRecording = {}
    local totalFrames = 0
    local timeOffset = 0
    local totalDuration = 0
    local successCount = 0

    for i, url in ipairs(urlList) do
        local success, response = pcall(function()
            return game:HttpGet(url)
        end)
        
        if success then
            if not response or response == "" then
                WindUI:Notify({
                    Title = "Warning",
                    Content = string.format("File %d (Kosong): %s", i, url),
                    Icon = "alert-circle",
                })
                continue
            end
            
            local loadSuccess, result = pcall(function()
                return loadstring("return " .. response)()
            end)
            
            if loadSuccess and type(result) == "table" and #result > 0 then
                
                -- Gabungkan Recording
                for _, frame in ipairs(result) do
                    local newFrame = frame
                    
                    -- Jika format frame array (time, x, y, z, ry, [anims])
                    if type(frame) == "table" and #frame >= 5 and type(frame[1]) == "number" then
                        -- Sesuaikan waktu frame dengan offset dari file sebelumnya
                        newFrame[1] = frame[1] + timeOffset
                    end
                    
                    table.insert(combinedRecording, newFrame)
                end
                
                -- Update offset untuk file berikutnya
                if #result > 0 then
                    local lastFrameTime = result[#result][1]
                    timeOffset = timeOffset + lastFrameTime
                    totalDuration = totalDuration + lastFrameTime
                end
                
                totalFrames = totalFrames + #result
                successCount = successCount + 1

            else
                WindUI:Notify({
                    Title = "Warning",
                    Content = string.format("File %d (Format Invalid): %s", i, url),
                    Icon = "x",
                })
            end
        else
            WindUI:Notify({
                Title = "Error",
                Content = string.format("Koneksi Gagal File %d: %s", i, tostring(response)),
                Icon = "wifi-off",
            })
        end
    end
    
    if totalFrames > 0 then
        if playbackPlayer:LoadRecording(combinedRecording) then
            WindUI:Notify({
                Title = "âœ… Success",
                Content = string.format("%s dimuat! (%d file, %d frames, %.1fs)", name, successCount, totalFrames, totalDuration),
                Icon = "check",
                Duration = 4,
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Gagal memuat ke sistem playback",
                Icon = "x",
            })
        end
    else
        WindUI:Notify({
            Title = "Error",
            Content = "Semua file gagal dimuat/kosong.",
            Icon = "x",
        })
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  UI SECTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MainSection = Window:Section({
    Title = "Main",
    Icon = "home",
})

local FeaturesSection = Window:Section({
    Title = "Features",
    Icon = "sparkles",
})

local InfoSection = Window:Section({
    Title = "Information",
    Icon = "info",
})

local SettingsSection = Window:Section({
    Title = "Settings",
    Icon = "settings",
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  MAIN TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local MainTab = MainSection:Tab({
    Title = "Main",
    Icon = "home",
})

-- Mountain Data (Updated to use URLs list)
local MountainList = {
    {
        Title = "â›°ï¸ Yahayuk (CP 1-5)",
        Icon  = "mountain",
        URLs  = {
            "https://raw.githubusercontent.com/VannDC/Tes/refs/heads/main/yahayuk/checkpoint_1.json",
            "https://raw.githubusercontent.com/VannDC/Tes/refs/heads/main/yahayuk/checkpoint_2.json",
            "https://raw.githubusercontent.com/VannDC/Tes/refs/heads/main/yahayuk/checkpoint_3.json",
            "https://raw.githubusercontent.com/VannDC/Tes/refs/heads/main/yahayuk/checkpoint_4.json",
            "https://raw.githubusercontent.com/VannDC/Tes/refs/heads/main/yahayuk/checkpoint_5.json",
        }
    },
    {
        Title = "ğŸŒ mapkedua (Single)",
        Icon  = "globe",
        URLs  = {
            "https://raw.githubusercontent.com/VannDC/Uploads/main/Walk_Replays.json" -- Single URL tetap di dalam tabel
        }
    }
}


local SelectedMountain = MountainList[1]

MainTab:Dropdown({
    Title = "Select Mountain",
    Desc  = "Choose a mountain to load",
    Values = MountainList,
    Value  = MountainList[1],
    Callback = function(option)
        SelectedMountain = option
        WindUI:Notify({
            Title   = "Mountain Selected",
            Content = option.Title,
            Icon    = "check",
        })
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Load Selected Mountain",
    Icon = "download",
    Color = Color3.fromHex("#3b82f6"),
    Justify = "Center",
    Callback = function()
        if SelectedMountain then
            LoadMountain(SelectedMountain.Title, SelectedMountain.URL)
        end
    end
})

MainTab:Space({ Columns = 3 })

MainTab:Section({
    Title = "Playback Controls",
})

MainTab:Space()

MainTab:Button({
    Title = "Play from Start",
    Icon = "play",
    Color = Color3.fromHex("#10b981"),
    Callback = function()
        if not playbackPlayer or #playbackPlayer.recording == 0 then
            WindUI:Notify({
                Title = "Error",
                Content = "Load mountain terlebih dahulu!",
                Icon = "alert-circle",
            })
            return
        end
        
        playbackPlayer.isPaused = false
        playbackPlayer.pausedIndex = nil
        _G.LoopCounter = 0
        
        playbackPlayer:ResetHeightMarkers()
        playbackPlayer.initialPlayerY = playbackPlayer.humanoidRootPart.Position.Y
        if #playbackPlayer.recording > 0 then
            playbackPlayer.initialRecordingY = playbackPlayer.recording[1][3]
        end
        playbackPlayer:CalculateHeightOffset()
        
        playbackPlayer:EnsureAnimatorReady()
        
        _G.ShouldAutoRestart = isLoopEnabled and playbackPlayer.autoKillOnFinish
        _G.RestartWithLoop = isLoopEnabled
        
        if playbackPlayer:PlayRecording(isLoopEnabled, 1) then
            WindUI:Notify({
                Title = "Playing",
                Content = "Auto walk dimulai!",
                Icon = "check",
            })
        end
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Play from Nearest",
    Icon = "map-pin",
    Color = Color3.fromHex("#3b82f6"),
    Callback = function()
        if not playbackPlayer or #playbackPlayer.recording == 0 then
            WindUI:Notify({
                Title = "Error",
                Content = "Load mountain terlebih dahulu!",
                Icon = "alert-circle",
            })
            return
        end
        
        playbackPlayer.isPaused = false
        playbackPlayer.pausedIndex = nil
        _G.LoopCounter = 0
        
        playbackPlayer:ResetHeightMarkers()
        playbackPlayer:EnsureAnimatorReady()
        
        _G.ShouldAutoRestart = isLoopEnabled and playbackPlayer.autoKillOnFinish
        _G.RestartWithLoop = isLoopEnabled
        
        -- Walk to nearest position first, then start playback
        local nearestIndex, nearestDistance = playbackPlayer:FindNearestWaypoint()
        
        if nearestDistance > 5 then
            -- Walk to the nearest position
            playbackPlayer:WalkToNearestPosition(function(reachedIndex)
                -- Start playback after reaching the position
                playbackPlayer:PlayRecording(isLoopEnabled, reachedIndex, true)
            end)
        else
            -- Already close, start directly
            if playbackPlayer:PlayRecording(isLoopEnabled, nearestIndex, true) then
                WindUI:Notify({
                    Title = "Playing",
                    Content = "Dimulai dari posisi terdekat!",
                    Icon = "check",
                })
            end
        end
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Pause",
    Icon = "pause",
    Color = Color3.fromHex("#f59e0b"),
    Callback = function()
        if not playbackPlayer then return end
        
        if playbackPlayer:PausePlayback() then
            WindUI:Notify({
                Title = "Paused",
                Content = "Auto walk dijeda",
                Icon = "check",
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Tidak bisa dijeda!",
                Icon = "x",
            })
        end
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Resume",
    Icon = "play-circle",
    Color = Color3.fromHex("#84cc16"),
    Callback = function()
        if not playbackPlayer then return end
        
        if playbackPlayer:ResumePaused() then
            WindUI:Notify({
                Title = "Resumed",
                Content = "Auto walk dilanjutkan",
                Icon = "check",
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Tidak bisa dilanjutkan!",
                Icon = "x",
            })
        end
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Stop",
    Icon = "square",
    Color = Color3.fromHex("#ef4444"),
    Callback = function()
        if playbackPlayer then
            playbackPlayer:StopPlayback()
            playbackPlayer.loopPlayback = false
            _G.ShouldAutoRestart = false
            
            WindUI:Notify({
                Title = "Stopped",
                Content = "Auto walk dihentikan",
                Icon = "check",
            })
        end
    end
})

MainTab:Space({ Columns = 3 })

MainTab:Section({
    Title = "Playback Options",
})

MainTab:Space()

MainTab:Toggle({
    Title = "Infinite Loop",
    Icon = "infinity",
    Default = false,
    Callback = function(state)
        isLoopEnabled = state
        if state then
            _G.LoopCounter = 0
            -- ğŸ”„ Enhanced loop initialization
            if playbackPlayer then
                playbackPlayer.loopPlayback = true
                playbackPlayer.autoKillOnFinish = false -- Disable auto kill for smoother looping
            end
        else
            -- ğŸ›‘ Clean loop disable
            if playbackPlayer then
                playbackPlayer.loopPlayback = false
            end
            _G.ShouldAutoRestart = false
            _G.RestartWithLoop = false
        end
        WindUI:Notify({
            Title = state and "ğŸ”„ Loop Enabled" or "â¹ï¸ Loop Disabled",
            Content = state and "Mode infinite loop aktif!" or "Mode infinite loop nonaktif",
            Icon = state and "infinity" or "square",
        })
    end
})

MainTab:Space()

MainTab:Slider({
    Title = "Playback Speed",
    Step = 0.1,
    Value = {
        Min = 0.1,
        Max = 3,
        Default = 1,
    },
    Callback = function(value)
        if playbackPlayer then
            playbackPlayer.playbackSpeed = value
        end
    end
})

MainTab:Space()

MainTab:Toggle({
    Title = "Auto Kill on Finish",
    Icon = "skull",
    Default = false,
    Callback = function(state)
        if playbackPlayer then
            playbackPlayer.autoKillOnFinish = state
        end
        WindUI:Notify({
            Title = state and "Enabled" or "Disabled",
            Content = state and "Auto kill on finish aktif" or "Auto kill on finish nonaktif",
            Icon = "check",
        })
    end
})

MainTab:Space()

MainTab:Toggle({
    Title = "Reverse Rotation",
    Icon = "rotate-ccw",
    Default = false,
    Callback = function(state)
        if playbackPlayer then
            playbackPlayer.reverseRotation = state
        end
        WindUI:Notify({
            Title = state and "Enabled" or "Disabled",
            Content = state and "Reverse rotation aktif" or "Reverse rotation nonaktif",
            Icon = "check",
        })
    end
})

MainTab:Space()

MainTab:Button({
    Title = "Reset Loop Counter",
    Icon = "refresh-cw",
    Color = Color3.fromHex("#6366f1"),
    Callback = function()
        _G.LoopCounter = 0
        WindUI:Notify({
            Title = "Reset",
            Content = "Loop counter direset ke 0",
            Icon = "check",
        })
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  FEATURES TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FeaturesTab = FeaturesSection:Tab({
    Title = "Features",
    Icon = "sparkles",
})

FeaturesTab:Toggle({
    Title = "Megang Coil",
    Icon = "wrench",
    Default = false,
    Callback = function(state)
        if state then
            if WeldRightArmForward() then
                megangCoilEnabled = true
                WindUI:Notify({
                    Title = "Enabled",
                    Content = "Megang coil diaktifkan",
                    Icon = "check",
                })
            end
        else
            UnweldRightArmForward()
            megangCoilEnabled = false
            WindUI:Notify({
                Title = "Disabled",
                Content = "Megang coil dinonaktifkan",
                Icon = "x",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "ğŸ­ Stable Animation Playback",
    Icon = "play",
    Default = true, -- âœ¨ DEFAULT ENABLE!
    Callback = function(state)
        stableAnimationEnabled = state
        WindUI:Notify({
            Title = state and "Enabled" or "Disabled",
            Content = state and "Smooth animation transitions ON" or "Standard animation mode",
            Icon = state and "check" or "x",
        })
    end
})

FeaturesTab:Space()

FeaturesTab:Slider({
    Title = "Animation Fade Time",
    Icon = "sliders",
    Min = 0.05,
    Max = 0.5,
    Default = 0.15,
    Callback = function(value)
        animationFadeTime = value
        WindUI:Notify({
            Title = "Updated",
            Content = string.format("Fade time: %.2fs", value),
            Icon = "check",
        })
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Black Screen",
    Icon = "eye-off",
    Default = false,
    Callback = function(state)
        if state then
            if not blackScreenGui then
                blackScreenGui = CreateBlackScreen()
            else
                blackScreenGui.Enabled = true
            end
            blackScreenEnabled = true
            WindUI:Notify({
                Title = "Enabled",
                Content = "Black screen diaktifkan",
                Icon = "check",
            })
        else
            if blackScreenGui then
                blackScreenGui.Enabled = false
            end
            blackScreenEnabled = false
            WindUI:Notify({
                Title = "Disabled",
                Content = "Black screen dinonaktifkan",
                Icon = "x",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "FPS Boost",
    Icon = "zap",
    Default = false,
    Callback = function(state)
        if state then
            EnableFPSBoost()
            WindUI:Notify({
                Title = "Enabled",
                Content = "FPS boost diaktifkan",
                Icon = "check",
            })
        else
            DisableFPSBoost()
            WindUI:Notify({
                Title = "Disabled",
                Content = "FPS boost dinonaktifkan",
                Icon = "x",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Animasi Gendong",
    Icon = "lock",
    Default = false,
    Callback = function(state)
        ToggleCarryAnimation(state)
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Noclip",
    Icon = "ghost",
    Default = false,
    Callback = function(state)
        noclipEnabled = state
        WindUI:Notify({
            Title = state and "Enabled" or "Disabled",
            Content = state and "Noclip diaktifkan" or "Noclip dinonaktifkan",
            Icon = "check",
        })
    end
})

FeaturesTab:Space()

FeaturesTab:Button({
    Title = "Load Anti-AFK",
    Icon = "shield",
    Color = Color3.fromHex("#10b981"),
    Callback = function()
        local ok, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/Halim11lim/-Fish-It/main/antafk"))()
        end)
        
        if ok then
            WindUI:Notify({
                Title = "Success",
                Content = "Anti-AFK berhasil dimuat",
                Icon = "check",
            })
        else
            WindUI:Notify({
                Title = "Error",
                Content = "Gagal memuat Anti-AFK",
                Icon = "x",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Button({
    Title = "ğŸ” Performance Monitor",
    Color = Color3.fromHex("#3b82f6"),
    Icon = "activity",
    Justify = "Center",
    Callback = function()
        local startTime = tick()
        local frameCount = 0
        local lastFPS = 0
        
        local monitorConnection
        monitorConnection = RunService.Heartbeat:Connect(function()
            frameCount = frameCount + 1
            local currentTime = tick()
            
            if currentTime - startTime >= 1 then
                lastFPS = math.floor(frameCount / (currentTime - startTime))
                frameCount = 0
                startTime = currentTime
                
                -- Performance status
                local status = lastFPS >= 30 and "ğŸŸ¢ Excellent" or lastFPS >= 20 and "ğŸŸ¡ Good" or "ğŸ”´ Poor"
                local memory = math.floor(game:GetService("Stats"):GetTotalMemoryUsageMb())
                
                WindUI:Notify({
                    Title = "ğŸ“Š Performance Stats",
                    Content = string.format("%s | FPS: %d | Memory: %dMB", status, lastFPS, memory),
                    Icon = "activity",
                    Duration = 2,
                })
            end
        end)
        
        -- Auto-stop after 30 seconds
        task.wait(30)
        if monitorConnection then
            monitorConnection:Disconnect()
        end
    end,
})

FeaturesTab:Space({ Columns = 3 })

FeaturesTab:Section({
    Title = "ğŸ” Security & Protection",
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Anti-Report",
    Icon = "shield-check",
    Default = false,
    Callback = function(state)
        if state then
            EnableAntiReport()
            WindUI:Notify({
                Title = "Enabled",
                Content = "Anti-report protection aktif",
                Icon = "shield-check",
            })
        else
            DisableAntiReport()
            WindUI:Notify({
                Title = "Disabled",
                Content = "Anti-report protection nonaktif",
                Icon = "shield-off",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Anti-Detect (Stealth)",
    Icon = "eye-off",
    Default = false,
    Callback = function(state)
        if state then
            EnableAntiDetect()
            WindUI:Notify({
                Title = "Enabled",
                Content = "Stealth mode aktif",
                Icon = "eye-off",
            })
        else
            DisableAntiDetect()
            WindUI:Notify({
                Title = "Disabled",
                Content = "Stealth mode nonaktif",
                Icon = "eye",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Private Mode",
    Icon = "user-x",
    Default = false,
    Callback = function(state)
        if state then
            EnablePrivateMode()
            WindUI:Notify({
                Title = "Enabled",
                Content = "Private mode aktif (invisible)",
                Icon = "user-x",
            })
        else
            DisablePrivateMode()
            WindUI:Notify({
                Title = "Disabled",
                Content = "Private mode nonaktif",
                Icon = "user",
            })
        end
    end
})

FeaturesTab:Space()

FeaturesTab:Toggle({
    Title = "Auto Leave on Admin",
    Icon = "log-out",
    Default = false,
    Callback = function(state)
        if state then
            EnableAutoLeaveAdmin()
            WindUI:Notify({
                Title = "Enabled",
                Content = "Auto leave admin aktif",
                Icon = "shield-alert",
            })
        else
            DisableAutoLeaveAdmin()
            WindUI:Notify({
                Title = "Disabled",
                Content = "Auto leave admin nonaktif",
                Icon = "shield-off",
            })
        end
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  INFO TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local InfoTab = InfoSection:Tab({
    Title = "Info",
    Icon = "info",
})

InfoTab:Section({
    Title = "Auto Walk Player V3.0",
    TextSize = 24,
})

InfoTab:Space()

InfoTab:Paragraph({
    Title = "Features",
    Desc = [[
âœ… 40 Mountains Available
â¸ï¸ Pause/Resume Movement
ğŸ“ Play from Nearest Position
â™¾ï¸ Infinite Loop Mode
ğŸ”„ Auto-Restart After Death
âš¡ Playback Speed Control
    ]],
})

InfoTab:Space()

InfoTab:Section({
    Title = "Available Mountains (40)",
    TextSize = 18,
})

InfoTab:Paragraph({
    Title = "New Features V3.0",
    Desc = [[
âœ¨ Enhanced Performance
âœ¨ Improved Stability
âœ¨ Better User Experience
    ]],
})

InfoTab:Space()

InfoTab:Paragraph({
    Title = "Mountain List",
    Desc = [[
1. â›°ï¸ Yahayuk
2. â›°ï¸ Yahayuk Kw
    ]],
})

InfoTab:Space()

InfoTab:Section({
    Title = "Credits",
    TextSize = 18,
})

InfoTab:Space()

InfoTab:Paragraph({
    Title = "Made by",
    Desc = [[
Script by: Kontol
UI Library: WindUI by Footagesus
Version: 3.0 Enhanced

ğŸ’– Thank you for using!
    ]],
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  SETTINGS TAB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local SettingsTab = SettingsSection:Tab({
    Title = "Settings",
    Icon = "settings",
})

SettingsTab:Toggle({
    Title = "Compact Mode",
    Icon = "minimize-2",
    Default = false,
    Callback = function(state)
        if state then
            WindUI:Notify({
                Title = "Compact Mode",
                Content = "UI minimized (restart required)",
                Icon = "minimize-2",
            })
        else
            WindUI:Notify({
                Title = "Normal Mode",
                Content = "UI size restored (restart required)",
                Icon = "maximize-2",
            })
        end
    end
})

SettingsTab:Space({ Columns = 2 })

SettingsTab:Section({
    Title = "âš™ï¸ Advanced Settings",
})

SettingsTab:Space()

SettingsTab:Button({
    Title = "Reset All Settings",
    Icon = "refresh-ccw",
    Color = Color3.fromHex("#ef4444"),
    Callback = function()
        -- Reset semua settings
        carryAnimationEnabled = false
        carryWeldActive = false
        megangCoilEnabled = false
        blackScreenEnabled = false
        fpsBoostEnabled = false
        noclipEnabled = false
        antiReportEnabled = false
        antiDetectEnabled = false
        privateModeEnabled = false
        autoLeaveAdminEnabled = false
        _G.LoopCounter = 0
        
        -- Unweld arms if active
        UnweldArmsFromCarry()
        UnweldRightArmForward()
        
        WindUI:Notify({
            Title = "Reset Complete",
            Content = "All settings reset to default",
            Icon = "check",
        })
    end
})

SettingsTab:Space()

SettingsTab:Button({
    Title = "Restart Script",
    Icon = "rotate-cw",
    Color = Color3.fromHex("#3b82f6"),
    Callback = function()
        WindUI:Notify({
            Title = "Restarting...",
            Content = "Script will restart in 2 seconds",
            Icon = "loader",
        })
        task.wait(2)
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Halim11lim/-Fish-It/main/walk_windui.lua"))()
    end
})

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--  FINAL INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WindUI:Notify({
    Title = "ğŸš€ Auto Walk V3.0 Enhanced",
    Content = "âœ… Script loaded successfully!\nğŸ­ Stable Animation: ENABLED\nâš¡ All features ready!",
    Icon = "check",
    Duration = 5,
})

task.wait(1)

WindUI:Notify({
    Title = "ğŸ­ Animation System",
    Content = "Stable playback is AUTO-ENABLED for smoother movements!",
    Icon = "play",
    Duration = 4,
})
